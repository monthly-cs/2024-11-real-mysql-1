# 쿼리 힌트
- MySQL 서버는 우리가 서비스하는 비즈니스를 100% 이해하지 못하니, 때로는 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 알려줄 수 있는 방법이 필요하다. 이런 목적으로 힌트가 제공된다.
- MySQL 서버에서는 `인덱스 힌트`와 `조인 힌트`를 제공한다.

## 인덱스 힌트
- 인덱스 힌트들은 모두 MySQL 서버에 옵티마이저 힌트가 도입되기 전에 사용되던 기능들이다.
- 인덱스 힌트들은 모두 sql의 문법에 맞게 사용해야 하기 때문에 사용하게 되면 ANSI-SQL표준 문법을 준수하지 못하게 되는 단점이 있다.
- MySQL 5.6 버전부터 추가되기 시작한 옵티마이저 힌트들은 모두 MySQL 서버를 제외한 다른 RDBMS에서는 주석으로 해석하기 때문에 ANSI-SQL표준을 준수한다고 볼 수 있다. 그래서 가능하면 옵티마이저 힌트를 사용하는 것이 좋다.

### STRAIGHT_JOIN
- STRAIGHT_JOIN은 옵티마이저 힌트인 동시에 조인 키워드 이기도 하다.
- SELECT 문에서 STRAIGHT_JOIN 키워드를 사용하면 FROM 절에 나열된 테이블 순서대로 조인을 수행하도록 강제할 수 있다.
- STRAIGHT_JOIN은 조인 순서를 변경하지 않고, FROM 절에 나열된 순서대로 조인을 수행하도록 강제하는 힌트이다.

### USE INDEX / FORCE INDEX / IGNORE INDEX
- USE INDEX
  - 가장 자주 사용되는 인덱스 힌트로, MySQL 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트 정도로 생각하면 된다.
- FORCE INDEX
  - USE INDEX와 비교해서 다른 점은 없으며, USE INDEX보다 옵티마이저에게 미치는 영향이 더 강한 힌트로 생각하면 된다.
- IGNORE INDEX
  - USE INDEX와 FORCE INDEX와는 반대로 특정 인덱스를 사용하지 못하게 하는 용도로 사용하는 힌트다.

### SQL_CALC_FOUND_ROWS
- MySQL의 LIMIT을 사용하는 경우, 조건을 만족하는 레코드가 LIMIT에 명시된 수보다 더 많다고 하더라도 LIMIT에 명시된 수만큼 만족하는 레코드를 찾으면 즉시 검색 작업을 멈춘다.
- 하지만 `SQL_CALC_FOUND_ROWS`힌트가 포함된 쿼리의 경우에는 LIMIT을 만족하는 수만큼의 레코드를 찾았다고 하더라도 끝까지 검색을 수행한다.
- 그래서 `SQL_CALC_FOUND_ROWS`힌트가 포함된 쿼리의 경우에는 LIMIT을 만족하는 레코드 수와 전체 레코드 수를 구할 수 있다.
- 하지만 `SQL_CALC_FOUND_ROWS`힌트가 포함된 쿼리의 경우에는 성능이 저하될 수 있으니 주의해야 한다.

---

## 옵티마이저 힌트

### 옵티마이저 힌트 종류
- 옵티마이저 힌트는 영향 범위에 따라 다음 4개 그룹으로 나누어 볼 수 있다.
  - 인덱스: 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
  - 테이블: 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
  - 쿼리블록: 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트로서, 특정 쿼리 블록의 이름을 명시하는 것이 아니라 힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 옵티마이저 힌트
  - 글로벌(쿼리 전체): 전체 쿼리에 대해서 영향을 미치는 힌트
