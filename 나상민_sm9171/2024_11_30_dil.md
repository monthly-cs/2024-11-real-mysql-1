# 나상민_2024_11_30_dil.md
## 진도

## 중요한 개념
### 싱글 패스 정렬 방식
- 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식이다.

### 투 패스 정렬 방식
- 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식으로, 
싱글 패스 정렬 방식이 도입되기 이전부터 사용하던 방식이다.
- 싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이라고 볼 수 있다.

### 인덱스를 이용한 정렬
- 인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
- WHERE절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
- B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다.

### 조인의 드라이빙 테이블만 정렬
- 조인을 실행하면 레코드가 몇 배로 늘어나기 때문에 조인을 실행하기 전에 첫 번째 테이블을 정렬한 다음 조인을 실행한다.
이 방법으로 정렬이 처리되려면 조인에서 첫 번째로 읽히는 테이블의 컬럼만으로 ORDER BY절을 작성해야 한다.

### 임시 테이블을 이용한 정렬
- 쿼리가 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수 있다.

### 쿼리가 처리되는 방법 - 스트리밍 방식
- 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식을 의미한다.
- 쿼리가 스트리밍방식으로 처리될 수 있다면 클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있다.

### 쿼리가 처리되는 방법 - 버퍼링 방식
- ORDER BY나 GROUP BY같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다.
우선 WHERE 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그루핑해서 차례대로 보내야 하기 때문이다.
- ORDER BY의 3가지 처리 방법중에 `인덱스를 사용한 정렬 방식`만 스트리밍 형태의 처리이다.

### 정렬 관련 상태 변수
```mysql
FLUSH STATUS;
SHOW STATUS LIKE 'Sort%';
```
- `Sort_merge_passes`는 멀티 머지 처리 횟수를 의미한다.
- `Sort_range`는 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수다.
- `Sort_scan`은 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수다. `Sort_scan`과 `Sort_range`는 둘 다 정렬 작업 횟수를 누적하고 있는 상태 값이다.
- `Sort_rows`는 지금까지 정렬한 전체 레코드 건수를 의미한다.

---
## GROUP BY 처리
- GROUP BY 또한 ORDER BY와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리 중 하나다.
- GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없다.

### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
- 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.
- GROUP BY가 인덱스를 사용해서 처리된다 하더라도 그룹 함수 등의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다.

### 루스 인덱스 스캔을 이용하는 GROUP BY
- 루스 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미하는데, 옵티마이저가 루스 인덱스 스캔을 사용할 때는 실행 계획의 Extra 칼럼에 "Using index for group-by"코멘트가 표시된다.
- 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다.
- 프리픽스 인덱스 는 루스 인덱스 스캔을 사용할 수 없다.
- 인덱스 레인지 스캔에서는 유니크한 값의 수가 많을수록 성능이 향상되는 반면 루스 인덱스 스캔에서는 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다.
- 다음 쿼리는 루스 인덱스 스캔을 사용할 수 없는 쿼리 패턴이다.
```mysql
-- // MIN()과 MAX() 이외의 집합 함수가 사용됐기 때문에 루스 인덱스 스캔은 사용 불가
SELECT col1, SUM(col2) FROM tb_test GROUP By col1;

-- // GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않기 때문에 사용 불가
SELECT col1, col2 FROM tb_test GROUP BY col2, col3;

-- // SELECT 절의 칼럼이 GROUP BY와 일치하지 않기 때문에 사용 불가
SELECT col1, col3 FROM tb_test GROUP BY col1, col2;

```
### 임시 테이블을 사용하는 GROUP BY
- GROUP BY의 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리된다.
- MySQL 8.0 이전 버전까지는 GROUP BY가 사용된 쿼리는 그루핑되는 칼럼을 기준으로 묵시적인 정렬까지 함께 수행했지만 MySQL 8.0부터는 이러한 묵시적인 정렬이 없어졌다.
- MySQL 8.0에서는 GROUP BY가 필요한 경우 내부적으로 GROUP BY 절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복제거와 집합 함수 연산을 수행한다.
- MySQL 5.7버전까지는 GROUP BY가 사용되면 자동으로 그루핑 칼럼을 기준으로 정렬이 수행됐는데, 정렬이 필요치 않은 경우라면 "ORDER BY NULL"을 사용해서 정렬을 생략할 수 있었다.
- MySQL 8.0부터는 GROUP BY가 사용된 쿼리에 대해 묵시적인 정렬이 없어졌기 때문에 "ORDER BY NULL"을 사용할 필요가 없어졌다.
---
### SELECT DISTINCT ...
- 단순히 SELECT되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 SELECT DISTINCT 형태의 쿼리 문장을 사용한다. 이 경우에는 GROUP BY와 동일한 방식으로 처리된다.
- DISTINCT는 SELECT하는 레코드(튜플)를 유니크하게 SELECT하는 것이지, 특정 칼럼만 유니크하게 조회하는 것이 아니다.
```mysql
-- // first_name과 last_name이 모두 같은 레코드는 하나로 처리
SELECT DISTINCT first_name, last_name FROM employees;

-- // DISTINCT 뒤에 괄호는 의미 없이 사용된 괄호로 해석하고 제거 됨, 결과적으로 위와 똑같은 쿼리
SELECT DISTINCT (first_name), last_name FROM employees;
```

### 집합 함수와 함께 사용된 DISTINCT
- COUNT() 또는 MIN(), MAX() 같은 집함 함수 내에서 DISTINCT 키워드가 사용될 수 있는데, 이 경우에는 일반적으로 SELECT DISTICT와 다른 형태로 해석된다.
- 집합 함수가 없는 SELECT DISTINCT는 조회하는 모든 칼럼의 조합이 유니크한 것들만 가져오지만, 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들만 가져온다.

---
## 내부 임시 테이블 활용
- MySQL엔진이 사용하는 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다.
- 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼수 없으며 사용하는 것도 불가능하다.
- 사용자가 생성한 임시테이블과는 달리 내부적인 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제된다.

### 메모리 임시 테이블과 디스크 임시 테이블
- MySQL8.0 이전 버전까지는 임시 테이블이 메모리를 사용할 때는 MEMORY 엔진을 사용하고, 디스크에 저장될 때는 MyISAM 엔진을 사용했다.
- MySQL8.0부터는 메모리는 TempTable이라는 스토리지 엔진을 사용하고, 디스크에 저장되는 임시 테이블은 InnoDB 엔진을 사용한다.
- 기존 MEMORY 스토리지 엔진은 VARBINARY나 VARCHAR 같은 가변 길이 타입을 지원하지 못하기 때문에 임시 테이블이 메모리에 만들어지면 가변 길이 타입의 경우 최대 길이만큼 메모리를 할당해서 사용했다.
MySQL 8.0부터는 TempTable 스토리지 엔진을 사용하면 가변 길이 타입을 지원하게 되었다.
- 임시 테이블의 크기가 1GB를 넘어가면 디스크로 옮겨지는 데 MMAP파일로 디스크에 기록하거나 InnoDB 테이블에 기록하게 된다. MMAP파일로 전환하는게 오버헤드가 적기때문에 MMAP파일로 전환하는 것이 기본값이다.

### 임시 테이블이 필요한 쿼리
- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 칼럼이 UNION RESULT인 경우)
- 쿼리의 실행 계획에서 select_tye이 DERIVED인 쿼리

### 임시 테이블이 디스크에 생성되는 경우
- UNION이나 UNION ALL에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 (MEMORY 스토리지 엔진에서) tmp_table_size 또는 max_heap_table_size보다크거나 (TempTable 스토리지 엔진에서) temptable_max_ram보다 큰 경우

### 임시 테이블 관련 상태 변수
```mysql
FLUSH STATUS;

SELECT first_name, last_name 
FROM employees
GROUP BY first_name, last_name;

SHOW SESSION STATUS LIKE 'Created_tmp%';
```

- Created_tmp_tables: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값이다. 이 값은 내부 임시 테이블이 메모리에 만들어졌는지 디스크에 만들어졌는지를 구분하지 않고 모두 누적한다.
- Created_tmp_disk_tables: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값이다.