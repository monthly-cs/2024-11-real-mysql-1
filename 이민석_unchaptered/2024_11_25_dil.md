# 8. 인덱스 (213~281p)


## 8.2. 인덱스란 (218~220p)

- 역할 별로 분류
    - Primary Key
    - Secondary Index(==Key)
- 데이터 저장 방식별 분류
    - B-Tree Index
    - R-Tree Index
    - Hash Index
    - Fractal-Tree Index
    - Merge-Tree Index
- 데이터 중복 허용 여부
    - Unique Index
    - Non-Unique Index

## 8.3. B-Tree 인덱스 (220~253p)

- B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.

### 8.3.1. 구조 및 특성 (220~223p)

- 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬돼 있찌 않고 임의의 순서로 저장되어 있다.
    - INSERT만 진행한다면 순차적으로 저장된다.
    - DELETE이후에는 해당 공간이 비어지고 추후 INSERT 되므로, 그 떄부터는 순차 저장이 되지 않는다.

### 8.3.2. B-Tree 인덱스 키 추가 및 삭제 (223~225p)

[쓰기]
- 리프 노드가 꽉차면 새로운 트리가 `분리(Split)`되며 많은 비용이 지불될 수 있음
- 인덱스가 많을 수록 쓰기 작업이 오래 걸림
    - 인덱스가 0개인 쓰기는 대략적으로 1 쓰기 시간 소모
    - 인덱스가 3개면 쓰기는 대략적으로 5.5 쓰기 사건 소모 (1.5 * 3 + 1)

[삭제]
- 리프 노드를 찾아서 삭제 마크를 처리
- 해당 공간은 방치되거나 추후 재활용될 수 있음

[변경]
- 인덱스 변경 시에 트리 내에서 위치 변경될 수 있음

[검색]
- B-Tree 구조에서 루트 -> 브랜츠 -> 최종 리프로 들어가는 트리 탐색 구조 사용
- 100% 일치 혹은 값의 앞부분만 일치하는 경우에 사용 가능

### 8.3.3. B-Tree 인덱스 사용에 영향을 미치는 요소 (225~230p)

[인덱스 키 값의 크기(226~227p)]
- 페이지 크기, 인덱스 크기에 따라서 `페이지당 인덱스 숫자가 달라짐ß`
- 페이지가 16KB일 때는, 페이지당 371 ~ 585 정도의 인덱스?ß
    - 하나의 값 44 byte = 인덱스키 32 byte, 자식 노드 12 byte, `372.36`
    - 하나의 값 28 byte = 인덱스키 16 byte, 자식 노드 12 byte, `585.14`
- 페이지가 32KB일 때는, 페이지당 744 ~ 1,170 정도의 인덱스?
    - 하나의 값 44 byte = 인덱스키 32 byte, 자식 노드 12 byte, `744.72`
    - 하나의 값 28 byte = 인덱스키 16 byte, 자식 노드 12 byte, `1,170.28`

[B-Tree 깊이(277p)]
- 페이지당 인덱스의 숫자가 `585`라고 한다면, 리프가 N인 경우 `585^N`의 인덱스를 담을 수 있다.
- 일정한 임계점을 넘을 때마다 리프의 길이가 1씩 늘어나서 DB 성능이 저하될 수 있다.
- 따라서 인덱스의 크기를 최대한 작게 설정하는 것이 좋다.

## 8.4. R-Tree 인덱스 (253~258p)

## 8.5. 전문 검색 인덱스 (258~265p)

## 8.6. 함수 기반 인덱스 (265~268p)

## 8.7. 멀티 벨류 인덱스 (268~270p)

## 8.8. 클러스터링 인덱스 (270~277p)

## 8.9. 유니크 인덱스 (277~279p)

## 8.10. 외래키 (279~281p)